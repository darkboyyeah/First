<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>继承模式</title>
</head>
<body>

</body>
<script>
/*
Father.prototype.lastName ="zhang";

function Father() {
	
}

function Son() {
	
}

function inherit(Target, Origin) {
		Target.prototype=Origin.prototype;
	
}

inherit(Son, Father);
var son = new Son();
*/


//圣杯模式
// function inherit(Target, Origin) {
// 	function F() {};
// 	F.prototype=Origin.prototype;
// 	Target.prototype = new F();   //一定要在new之前改原型
// 	Target.prototype.constructor = Target;
// 	Target.prototype.uber = Origin.prototype;
// }
// Father.prototype.lastName = "haha";
// function Son() {
// }

// function Father() {
// }
// inherit(Son,Father);
// var father = new Father();
// var son = new Son();



	//私有化变量
	function Deng(name,wife) {
		var prepareWife = "xiaozhang";

		this.name = name;
		this.wife = wife;
		this.divorce = function() {
			this.wife = prepareWife;
		}
		this.changePreparewife = function(target) {
			prepareWife = target;
		}
		this.sayPreparewife = function() {
			console.log(prepareWife);
		}
	}
	var deng = new Deng('deng','xiaoliu');



	// 类式继承    两个缺点：1、当一个子类的实例更改了从父类构造函数继承来的共有属性就会影响其他子类；
	// 2、无法对父类构造函数内的属性进行初始化。
	// 申明父类
	// function SuperClass() {
	// 	this.superValue = true;
	// }
	// //为父类添加共有方法
	// SuperClass.prototype.getSuperValue = function() {
	// 	return this.superValue;
	// };
	// //申明子类
	// function SubClass() {
	// 	this.SubValue = false;
	// }
	// //继承父类
	// SubClass.prototype = new SuperClass();
	// //为子类添加共有方法
	// SubClass.prototype.getSubValue = function() {
	// 	return this.SubValue;
	// };
	// var instance = new SubClass();





	//构造函数式继承
	
	//申明父类

	// function SuperClass(id) {
	// 	//引用类型共有属性
	// 	this.books = ['JavaScript','html','css'];
	// 	//值类型共有属性
	// 	this.id = id;
	// }
	// //父类声明原型方法
	
	// SuperClass.prototype.showBooks = function() {
	// 	console.log(this.books);
	// }

	// //声明子类

	// function SubClass(id) {
	// 	//继承父类
	// 	SuperClass.call(this,id);
	// }

	// //创建子类实例
	// var instance1 = new SubClass(1);
	// var instance2 = new SubClass(2);

	// instance1.books.push("设计模式");
	// console.log(instance1.books);
	// console.log(instance1.id);
	// console.log(instance2.books);
	// console.log(instance2.id);
	// instance1.showBooks();



	//组合继承
/*
	function SuperClass(name) {
		//值类型共有属性
		this.name = name;
		//引用类型共有属性
		this.books = ['html','css','js'];
	}

	//父类原型共有方法

	SuperClass.prototype.getName = function() {
		console.log(this.name);
	};

	//声明子类
	function SubClass(name,time) {
		//构造函数式继承父类name属性
		SuperClass.call(this,name);
		//子类中新增共有属性
		this.time=time;
	}

	//类式继承  子类原型继承父类

	SubClass.prototype = new SuperClass();
	//子类原型方法
	SubClass.prototype.getTime = function() {
		console.log(this.time);
	};

	var instance1 = new SubClass('js','book',2014);
	instance1.books.push('设计模式');
	console.log(instance1.books);
	instance1.getName();
*/


		//原型式继承

/*
	function inherit(o) {
		//声明一个过度函数对象
		function F(){};
		//过度对象的原型继承父类对象
		F.prototype = o;
		//返回过度对象的一个实例，该实例的原型继承了父对象
		return new F();
	}

	var book = {
		name : "js book",
		alikeBook : ['css book','html book']
	};
	var newBook = inherit(book);
	newBook.name = 'ajax book';
	newBook.alikeBook.push('xml book');

	var otherBook = inherit(book);
	otherBook.name = 'flash book';
	otherBook.alikeBook.push('as book');
*/

	//寄生式继承

	// function inherit(o) {
	// 	//申明一个过渡函数对象
	// 	function F(){};
	// 	//过渡对象的原型继承父类对象
	// 	F.prototype = o;
	// 	//返回过渡对象的一个实例，该实例的原型继承了父对象
	// 	return new F();
	// }
	// //声明基对象
	// var book = {
	// 	name : 'js book',
	// 	alikeBook : ['css book','html book']
	// };
	// function createBook(obj) {
	// 	//通过原型继承方式创建新对象
	// 	var o = new inherit(obj);
	// 	//拓展新对象
	// 	o.getName = function(){
	// 		console.log(this.name);
	// 	};
	// 	//返回拓展后的新对象
	// 	return o;
	// }

	// var instance1=createBook(book);
	// instance1.name='ss';
	// instance1.alikeBook.push('ff');

</script>
</html>
